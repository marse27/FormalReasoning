  From Coq Require Import Arith.PeanoNat. (* Required for nat *)
  From Coq Require Import Lists.List. (* Required for list *)
  From Coq Require Import micromega.Lia. (* Required for the 'lia' tactic *)
  From Coq Require Import funind.Recdef. (* Required for the 'function' definition *)
  From Coq Require Import Sorting.Permutation. (* Required for Permutation *)
  From Coq Require Import Sorting.Sorted. (* Required for StronglySorted *)
  Import ListNotations. (* Required for list notations *)

  (*---------------------------- Exercice 1 ----------------------------*)

  Module Exercice1.

  Fixpoint insert (n : nat) (l : list nat) : list nat :=
    match l with
    | [] => [n]
    | h :: t =>
        if Nat.leb n h
        then n :: l
        else h :: insert n t
    end.

  Fixpoint insertion_sort (l : list nat) : list nat :=
    match l with
    | [] => []
    | h :: t => insert h (insertion_sort t)
    end.

  Example sort_pi :
    insertion_sort [3; 1; 4; 1; 5; 9; 2; 6; 5; 3; 5]
    = [1; 1; 2; 3; 3; 4; 5; 5; 5; 6; 9].
  Proof. reflexivity. Qed.

  End Exercice1.

  (*---------------------------- Exercice 2 ----------------------------*)

  Module Exercice2.
  Import Exercice1.

   Lemma insert_perm:
    forall (a: nat) (l: list nat),
      Permutation (a :: l) (insert a l).
  Proof.
    induction l as [| h t IH].
    - simpl. apply Permutation_refl.
    - simpl. destruct (Nat.leb a h) eqn:EH.
      + apply Permutation_refl.
      + eapply perm_trans.
        * apply perm_swap.
        * apply perm_skip. exact IH.
  Qed.

  Lemma insertion_sort_perm:
    forall (l: list nat),
      Permutation l (insertion_sort l).
  Proof.
    induction l as [| h t IH].
    - simpl. apply Permutation_refl.
    - simpl. eapply perm_trans.
      + apply perm_skip. exact IH.
      + apply insert_perm.
  Qed.

  End Exercice2.

  (*---------------------------- Exercice 3 ----------------------------*)

  Module Exercice3.
  Import Exercice1.

  Definition Sorted (l: list nat): Prop :=
  forall (i j iv jv: nat),
    i < j ->
      nth_error l i = Some iv ->
        nth_error l j = Some jv ->
          iv <= jv.

  Lemma Sorted_cons_iff :
      forall (a : nat) (l : list nat),
        Sorted l /\ Forall (le a) l <-> Sorted (a :: l).
  Proof.
    split.
    - intros [Hs Hl]. unfold Sorted in *.
      intros i j iv jv Hij Hi Hj.
      simpl in Hi, Hj.
      destruct j as [| j']; [inversion Hij|].
      destruct i as [| i'].
      + inversion Hi; subst iv. 
        simpl in Hj.
        eapply Forall_forall in Hl. 
          -- exact Hl. 
          -- now apply nth_error_In in Hj.
      + assert (i' < j') by lia. 
        eapply Hs; eauto.
    - intros H. split.
      + unfold Sorted in *.
        intros i j iv jv Hij Hi Hj.
        assert (S i < S j) by lia.
        specialize (H (S i) (S j) iv jv H0).
        simpl in H.
        rewrite Hi in H. rewrite Hj in H.
        apply H.
          * reflexivity.
          * reflexivity.
      + apply Forall_forall. 
        intros x HIn.
        apply In_nth_error in HIn as [j' Hj'].
        unfold Sorted in H.
        assert (0 < S j') as Hlt by lia.
        specialize (H 0 (S j') a x Hlt).
        simpl in H.
        rewrite Hj' in H. apply H.
          * reflexivity.
          * reflexivity.
  Qed.

  End Exercice3.

  (*---------------------------- Exercice 4 ----------------------------*)

  Module Exercice4.
  Import Exercice1.
  Import Exercice3.

  (*---------------------------- Exercice 4.1 ----------------------------*)


  Lemma Forall_le_trans :
  forall (l : list nat) (a x : nat),
    a <= x ->
    Forall (fun y => x <= y) l ->
    Forall (fun y => a <= y) l.
  Proof.
    intros l a x Hax Hall.
    induction Hall as [| y t Hyx Hall' IH].
    - constructor.
    - constructor.
      + assert (a <= y) as Hay.
        { apply (Nat.le_trans a x y).
          * exact Hax.
          * exact Hyx.
        }
        exact Hay.
      + exact IH.
  Qed.

Lemma Forall_le_insert :
  forall x a l,
    Forall (fun z => x <= z) l ->
    x <= a ->
    Forall (fun z => x <= z) (insert a l).
Proof.
  intros x a l Hl Hxa.
  revert a Hxa.
  induction Hl as [| y ys Hy Hys IH].
  - intros a Hxa'. simpl.
    constructor.
    + exact Hxa'.
    + constructor.
  - intros a Hxa'. simpl.
    destruct (a <=? y) eqn:Hay.
    + constructor.
      * exact Hxa'.
      * constructor.
        -- exact Hy.
        -- exact Hys.
    + constructor.
      * exact Hy.
      * assert (Forall (fun z => x <= z) (insert a ys)) as Htail.
        { apply IH.
          exact Hxa'.
        }
        exact Htail.
Qed.

  Lemma insert_sorted:
    forall (a: nat) (l: list nat),
      Sorted l ->
        Sorted (insert a l).
  Proof.
    intros a l Hs; revert a.
    induction l as [|x xs IH]; intros a; simpl.
    - apply (proj1 (Sorted_cons_iff a [])).
      split. 
        -- exact Hs.
        -- constructor.
    - destruct (a <=? x) eqn:Hab.
      + apply (proj1 (Sorted_cons_iff a (x :: xs))).
        split.
        --- exact Hs.
        --- constructor.
            ++ apply Nat.leb_le in Hab.
               exact Hab.
            ++ destruct (proj2 (Sorted_cons_iff x xs) Hs) as [Hxs Hforx].
               eapply Forall_le_trans. 
               apply Nat.leb_le in Hab. 
               exact Hab.
               exact Hforx.
      + apply Nat.leb_gt in Hab.
        apply (proj1 (Sorted_cons_iff x (insert a xs))).
        split.
         * destruct (proj2 (Sorted_cons_iff x xs) Hs) as [Hxs _].
           apply IH.
           apply Hxs.
         * destruct (proj2 (Sorted_cons_iff x xs) Hs) as [_ Hforx].
           apply Forall_le_insert.
             ** exact Hforx. 
             ** lia.
  Qed.

  (*---------------------------- Exercice 4.2 ----------------------------*)

  Lemma insertion_sort_sorted:
    forall (l: list nat),
      Sorted (insertion_sort l).
  Proof.
    induction l as [| h t IH ].
    - simpl.
      unfold Sorted. 
      intros i j iv jv Hij Hi Hj.
      destruct i as [|i']. 
      simpl in Hi.
      + discriminate.
      + destruct j as [|j']. 
        * lia.
        * discriminate.
    - simpl. 
      apply insert_sorted.
      exact IH.
  Qed.

  End Exercice4.


  (*---------------------------- Exercice 5 ----------------------------*)

  Module Exercice5.
  Import Exercice1.
  Import Exercice2.
  Import Exercice3.
  Import Exercice4.

  Definition is_a_sorting_algorithm (f: list nat -> list nat): Prop :=
    forall (l: list nat),
      Permutation l (f l) /\ Sorted (f l).

  Lemma insertion_sort_is_a_sorting_algorithm:
    is_a_sorting_algorithm insertion_sort.
  Proof.
    unfold is_a_sorting_algorithm.
    intro l.
    split.
    - apply insertion_sort_perm.
    - apply insertion_sort_sorted.
  Qed.

  End Exercice5.

  (*---------------------------- Exercice 6 - Moderate ----------------------------*)

  Module Exercice6Moderate.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  (*---------------------------- Exercice 6.1 - Moderate ----------------------------*)


  Lemma bubble_pass_perm :
    forall (l : list nat),
      Permutation l (bubble_pass l).
  Proof.
    intro l.
    functional induction (bubble_pass l) using bubble_pass_ind.
    - (* [] *) apply Permutation_refl.
    - (* [x] *) apply Permutation_refl.
    - (* x :: y :: l', with x <? y = true *)
      apply perm_skip.
      remember (y :: l') as r eqn:Hr. exact IHl0.
    - (* x :: y :: l', with x <? y = false *)
      eapply perm_trans.
      + apply perm_swap.
      + apply perm_skip. exact IHl0.
  Qed.

  (*---------------------------- Exercice 6.2 - Moderate ----------------------------*)

  Lemma bubble_pass_perm_iter :
    forall (n : nat) (l : list nat),
      Permutation l (Nat.iter n bubble_pass l).
  Proof.
    induction n as [| n IH]; intros l; simpl.
    - apply Permutation_refl.
    - eapply Permutation_trans.
      + apply IH.
      + apply bubble_pass_perm.
  Qed.

  (*---------------------------- Exercice 6.3 - Moderate ----------------------------*)

  Lemma bubble_sort_perm :
    forall (l : list nat),
      Permutation l (bubble_sort l).
  Proof.
    intros l.
    unfold bubble_sort.
    apply bubble_pass_perm_iter.
  Qed.

  End Exercice6Moderate.

  (*---------------------------- Exercice 6 - Hard ----------------------------*)

  Module Exercice6Hard.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  Fixpoint list_max (l : list nat) :=
  match l with
  | [] => 0
  | x::xs => Nat.max x (list_max xs)
  end.

  (*---------------------------- Exercice 6.1 - Hard ----------------------------*)

  Lemma bubble_pass_moves_max_to_tail :
    forall (a : nat) (l : list nat),
      exists (b : nat) (l' : list nat),
        bubble_pass (a :: l) = l' ++ [b] /\ list_max (a :: l) = b.
  Proof.
    intros.
    revert a.
    induction l as [| x tl IH]; intros a; simpl.
    - exists a, []. split.
      + rewrite bubble_pass_equation. reflexivity.
      + rewrite Nat.max_0_r. reflexivity.
    - rewrite bubble_pass_equation.
      destruct tl as [| y tl'].
      + destruct (a <? x) eqn:Hax; simpl.
        * exists x, [a]. split. rewrite bubble_pass_equation. reflexivity.
          rewrite Nat.max_0_r. apply Nat.max_r. apply Nat.ltb_lt in Hax; lia.
        * exists a, [x]. split. rewrite bubble_pass_equation. reflexivity.
          rewrite Nat.max_0_r. apply Nat.max_l. apply Nat.ltb_ge in Hax; lia.
      + destruct (a <? x) eqn:Hax; simpl.
        * pose proof (IH x) as [b [l1 [Hbub Hmax]]].
          rewrite Hbub. exists b, (a :: l1). split; [reflexivity|].
          replace (Nat.max x (Nat.max y (list_max tl')))
          with (list_max (x :: y :: tl')) by (simpl; reflexivity). rewrite Hmax. apply Nat.max_r.
          assert (Hx_le_b : x <= b).
          { rewrite <- Hmax. simpl. apply Nat.le_max_l. } 
          apply Nat.le_trans with (m := x).
            -- (* a ≤ x *)
              apply Nat.lt_le_incl.                (* turn < into ≤ *)
              apply Nat.ltb_lt in Hax; exact Hax.  (* from a<?x=true get a<x *)
            -- (* x ≤ b *)
              exact Hx_le_b.
        * pose proof (IH a) as [b [l1 [Hbub Hmax]]]. 
          rewrite Hbub. exists b, (x :: l1). split; [reflexivity|].
          apply Nat.ltb_ge in Hax.  (* Hax : x ≤ a *)
          (* reassociate so (Nat.max a x) appears, then kill it using x ≤ a *)
          rewrite Nat.max_assoc.
          rewrite (Nat.max_l _ _ Hax).  (* turns Nat.max a x into a *)
          (* Now the goal is exactly list_max (a :: y :: tl') = b *)
          simpl in Hmax. simpl in Hmax.  (* list_max (a::y::tl') ⇒ Nat.max a (Nat.max y (list_max tl')) *)
          exact Hmax.
  Qed.


  (*---------------------------- Exercice 6.2 - Hard ----------------------------*)

Lemma bubble_pass_snoc_aux :
  forall (a b: nat) (l: list nat),
    list_max (a :: l) <= b ->
    bubble_pass (a :: l ++ [b]) = bubble_pass (a :: l) ++ [b].
Proof.
  intros a b l.
  revert a.                                 (* ← generalize the head *)
  induction l as [| z tl' IH]; intros a Hle; simpl.
  - (* l = [] *)
    rewrite bubble_pass_equation.
    destruct (a <? b) eqn:Hab; simpl.
    + rewrite bubble_pass_equation. rewrite bubble_pass_equation.  reflexivity.
    + apply Nat.ltb_ge in Hab as Hba.       (* b <= a *)
      assert (Ha_le : a <= b)
        by (simpl in Hle; eapply Nat.le_trans; [apply Nat.le_max_l| exact Hle]).
      apply Nat.le_antisymm in Ha_le; [subst|exact Hba].
      rewrite bubble_pass_equation. reflexivity.
  - (* l = z :: tl' *)
    simpl in Hle.                            (* max a (max z (list_max tl')) <= b *)
    assert (Hle_ztl : list_max (z :: tl') <= b)
      by (eapply Nat.le_trans; [apply Nat.le_max_r| exact Hle]).
    assert (Ha_le : a <= b)
      by (eapply Nat.le_trans; [apply Nat.le_max_l| exact Hle]).
    assert (Hle_tl' : list_max tl' <= b)
      by (eapply Nat.le_trans; [apply Nat.le_max_r| exact Hle_ztl]).
    assert (Hle_a_tl' : list_max (a :: tl') <= b).
    { simpl. apply Nat.max_lub; [exact Ha_le| exact Hle_tl']. }

    rewrite bubble_pass_equation.
    destruct (a <? z) eqn:Haz; simpl.
    + (* then: a stays; recurse on (z :: tl') *)
    specialize (IH z Hle_ztl).
    rewrite IH.
    (* Normalize the RHS head-step using Haz = true *)
    assert (Hhead :
      bubble_pass (a :: z :: tl') = a :: bubble_pass (z :: tl')).
    { rewrite bubble_pass_equation. rewrite Haz. reflexivity. }
    rewrite Hhead.
    reflexivity.
    + (* else: z stays; recurse on (a :: tl') *)
    specialize (IH a Hle_a_tl').
    rewrite IH.
    (* Same trick on the LHS match, but for (a :: tl') *)
    (* Normalize RHS head-step with Haz = false *)
    assert (Hhead :
      bubble_pass (a :: z :: tl') = z :: bubble_pass (a :: tl')).
    { rewrite bubble_pass_equation. rewrite Haz. reflexivity. }
    rewrite Hhead.
    reflexivity.
Qed.

  (*---------------------------- Exercice 6.3 - Hard ----------------------------*)


Lemma bubble_pass_snoc :
  forall (a: nat) (l: list nat),
    list_max l <= a ->
    bubble_pass (l ++ [a]) = bubble_pass l ++ [a].
Proof.
  intros a l H.
  destruct l as [| x tl]; simpl.
  - (* l = [] *)
    rewrite bubble_pass_equation, bubble_pass_equation. reflexivity.
  - (* l = x :: tl *)
    (* reuse the auxiliary with head x, tail tl, bound a *)
    apply bubble_pass_snoc_aux. exact H.
Qed.



  (*---------------------------- Exercice 6.4 - Hard ----------------------------*)
(* Stronger helper with the right quantifiers: generalize z before inducting on tl *)
Lemma bubble_pass_cons_max_le :
  forall z tl, list_max (bubble_pass (z :: tl)) <= Nat.max z (list_max tl).
Proof.
  (* introduce both in the right order, then keep z generic during IH on tl *)
  intros z tl.
  revert z.
  induction tl as [| y tl IH]; intro z; simpl.
  - rewrite bubble_pass_equation. simpl. lia.
  - rewrite bubble_pass_equation. simpl.
    destruct (z <? y) eqn:Hz; simpl.
    + (* z :: bubble_pass (y :: tl) *)
      apply Nat.max_lub.
      * apply Nat.le_max_l.
      * specialize (IH y).                       (* <= max y (list_max tl) *)
        eapply Nat.le_trans; [exact IH|].
        apply Nat.le_max_r.                      (* lift into max z ... *)
    + (* y :: bubble_pass (z :: tl) *)
      apply Nat.max_lub.
      * eapply Nat.le_trans; [apply Nat.le_max_l|]. apply Nat.le_max_r.
      * specialize (IH z).                       (* <= max z (list_max tl) *)
        eapply Nat.le_trans; [exact IH|].
        lia.
Qed.


(* One-liner corollary *)
Lemma bubble_pass_max_le :
  forall l, list_max (bubble_pass l) <= list_max l.
Proof.
  destruct l as [|x tl]; simpl.
  - rewrite bubble_pass_equation. simpl. apply Nat.le_refl.
  - apply bubble_pass_cons_max_le.
Qed.

Lemma list_max_iter_bubble_pass_le :
  forall n l, list_max (Nat.iter n bubble_pass l) <= list_max l.
Proof.
  induction n as [|n IH]; intros l; simpl.
  - apply Nat.le_refl.
  - eapply Nat.le_trans; [apply bubble_pass_max_le|apply IH].
Qed.

Lemma bubble_pass_snoc_iter :
  forall (a n: nat) (l: list nat),
    list_max l <= a ->
    Nat.iter n bubble_pass (l ++ [a]) = Nat.iter n bubble_pass l ++ [a].
Proof.
  intros a n l Hle.
  induction n as [|n IH]; simpl.
  - reflexivity.
  - rewrite IH.
    apply bubble_pass_snoc.
    eapply Nat.le_trans; [apply list_max_iter_bubble_pass_le|exact Hle].
Qed.


  End Exercice6Hard.


  (*---------------------------- Exercice 6 - Very Hard ----------------------------*)

  Module Exercice6VeryHard.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
  match l with
    | [] => []
    | [x] => [x]
    | x :: y :: l' =>
      if x <? y then
        x :: bubble_pass (y :: l')
      else
        y :: bubble_pass (x :: l')
  end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  (*---------------------------- Exercice 6.1 - Very Hard ----------------------------*)


  Lemma SSorted_snoc:
    forall {T: Type} (R: T -> T -> Prop) (t: T) (l: list T),
      StronglySorted R l ->
        Forall (fun (x: T) => R x t) l ->
          StronglySorted R (l ++ [t]).
  Proof.
    intros T R t l Hss.
    revert t.
    induction Hss as [| a l' Hss IH Hall]; intros t Ht; simpl.
    - (* l = [] *)
      constructor. constructor. constructor.
    - (* l = a :: l' *)
      inversion Ht as [| ? ? Hat Ht']; subst.
      constructor.
      + (* tail stays strongly sorted *)
        apply IH. exact Ht'.
      + (* every element in tail is <= a, and also a <= t *)
        apply Forall_app; split.
        * exact Hall.
        * constructor; [exact Hat | constructor].
  Qed.

  (*---------------------------- Exercice 6.2 - Very Hard ----------------------------*)

  End Exercice6VeryHard

