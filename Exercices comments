  From Coq Require Import Arith.PeanoNat. (* Required for nat *)
  From Coq Require Import Lists.List. (* Required for list *)
  From Coq Require Import micromega.Lia. (* Required for the 'lia' tactic *)
  From Coq Require Import funind.Recdef. (* Required for the 'function' definition *)
  From Coq Require Import Sorting.Permutation. (* Required for Permutation *)
  From Coq Require Import Sorting.Sorted. (* Required for StronglySorted *)
  Import ListNotations. (* Required for list notations *)

  (*---------------------------- Exercice 1 ----------------------------*)

  Module Exercice1.

  Fixpoint insert (n : nat) (l : list nat) : list nat :=
    match l with
    | [] => [n]
    | h :: t =>
        if Nat.leb n h
        then n :: l
        else h :: insert n t
    end.

  Fixpoint insertion_sort (l : list nat) : list nat :=
    match l with
    | [] => []
    | h :: t => insert h (insertion_sort t)
    end.

  Example sort_pi :
    insertion_sort [3; 1; 4; 1; 5; 9; 2; 6; 5; 3; 5]
    = [1; 1; 2; 3; 3; 4; 5; 5; 5; 6; 9].
  Proof. reflexivity. Qed.

  End Exercice1.

  (*---------------------------- Exercice 2 ----------------------------*)

  Module Exercice2.
  Import Exercice1.

  Lemma insert_perm:
    forall (a: nat) (l: list nat),
      Permutation (a :: l) (insert a l).
  Proof.
    induction l as [| h t IH].
    - (* Case l = [] *)
      simpl. 
      apply Permutation_refl.
    - (* Case l = h :: t *)
      simpl. 
      destruct (Nat.leb a h) eqn:EH.
        + (* Case a <= h*) 
          apply Permutation_refl.
        + (* Case a > h*) 
          eapply perm_trans.
            * apply perm_swap.
            * apply perm_skip. 
              exact IH.
  Qed.

  Lemma insertion_sort_perm:
    forall (l: list nat),
      Permutation l (insertion_sort l).
  Proof.
    induction l as [| h t IH].
    - (* Case l = [] *)
      simpl. 
      apply Permutation_refl.
    - (* Case l = h :: t *)
      simpl. 
      eapply perm_trans.
        + apply perm_skip. 
          exact IH.
        + apply insert_perm.
  Qed.

  End Exercice2.

  (*---------------------------- Exercice 3 ----------------------------*)

  Module Exercice3.
  Import Exercice1.

  Definition Sorted (l: list nat): Prop :=
  forall (i j iv jv: nat),
    i < j ->
      nth_error l i = Some iv ->
        nth_error l j = Some jv ->
          iv <= jv.

  Lemma Sorted_cons_iff :
      forall (a : nat) (l : list nat),
        Sorted l /\ Forall (le a) l <-> Sorted (a :: l).
  Proof.
    split.
    - intros [Hs Hl]. unfold Sorted in *.
      intros i j iv jv Hij Hi Hj.
      simpl in Hi, Hj.
      destruct j as [| j'].
        + inversion Hij.
        + destruct i as [| i'].
          * inversion Hi; subst iv.
            simpl in Hj.
            eapply Forall_forall in Hl.
            apply Hl.
            now apply nth_error_In in Hj.
          * assert (i' < j').
            {
              lia.
            }
            eapply Hs; eauto.
    - intros H. 
      split.
        + unfold Sorted in *.
          intros i j iv jv Hij Hi Hj.
          assert (S i < S j).
          {
            lia.
          }
          specialize (H (S i) (S j) iv jv H0).
          simpl in H.
          rewrite Hi in H. 
          rewrite Hj in H.
          apply H.
            * reflexivity.
            * reflexivity.
        + apply Forall_forall. 
          intros x HIn.
          apply In_nth_error in HIn as [j' Hj'].
          unfold Sorted in H.
          assert (0 < S j') as Hlt.
          {
            lia.
          } 
          specialize (H 0 (S j') a x Hlt).
          simpl in H.
          rewrite Hj' in H.
          apply H.
            * reflexivity.
            * reflexivity.
  Qed.

  End Exercice3.

  (*---------------------------- Exercice 4 ----------------------------*)

  Module Exercice4.
  Import Exercice1.
  Import Exercice3.

  (*---------------------------- Exercice 4.1 ----------------------------*)


  Lemma Forall_insert_trans :
  forall (l : list nat) (a x : nat),
    a <= x ->
    Forall (fun y => x <= y) l ->
    Forall (fun y => a <= y) l.
  Proof.
    intros l a x Hax Hall.
    induction Hall as [| y t Hyx Hall' IH].
    - constructor.
    - constructor.
      + assert (a <= y) as Hay.
        { 
          apply (Nat.le_trans a x y).
            * exact Hax.
            * exact Hyx.
        }
        exact Hay.
      + exact IH.
  Qed.

  Lemma Forall_insert :
    forall x a l,
      Forall (fun z => x <= z) l ->
      x <= a ->
      Forall (fun z => x <= z) (insert a l).
  Proof.
    intros x a l Hl Hxa.
    revert a Hxa.
    induction Hl as [| y ys Hy Hys IH].
    - intros a Hxa'. simpl.
      constructor.
      + exact Hxa'.
      + constructor.
    - intros a Hxa'. simpl.
      destruct (a <=? y) eqn:Hay.
      + constructor.
        * exact Hxa'.
        * constructor.
          -- exact Hy.
          -- exact Hys.
      + constructor.
        * exact Hy.
        * assert (Forall (fun z => x <= z) (insert a ys)) as Htail.
          { 
            apply IH.
            exact Hxa'.
          }
          exact Htail.
  Qed.

  Lemma insert_sorted:
    forall (a: nat) (l: list nat),
      Sorted l ->
        Sorted (insert a l).
  Proof.
    intros a l Hs; revert a.
    induction l as [|x xs IH]; intros a; simpl.
    - apply (proj1 (Sorted_cons_iff a [])).
      split. 
        + exact Hs.
        + constructor.
    - destruct (a <=? x) eqn:Hab.
        + apply (proj1 (Sorted_cons_iff a (x :: xs))).
          split.
            * exact Hs.
            * constructor.
                ++ apply Nat.leb_le in Hab.
                   exact Hab.
                ++ destruct (proj2 (Sorted_cons_iff x xs) Hs) as [Hxs Hforx].
                   eapply Forall_insert_trans. 
                   apply Nat.leb_le in Hab. 
                   exact Hab.
                   exact Hforx.
        + apply Nat.leb_gt in Hab.
          apply (proj1 (Sorted_cons_iff x (insert a xs))).
          split.
            * destruct (proj2 (Sorted_cons_iff x xs) Hs) as [Hxs _].
               apply IH.
               apply Hxs.
            * destruct (proj2 (Sorted_cons_iff x xs) Hs) as [_ Hforx].
               apply Forall_insert.
                 ++ exact Hforx. 
                 ++ lia.
  Qed.

  (*---------------------------- Exercice 4.2 ----------------------------*)

  Lemma insertion_sort_sorted:
    forall (l: list nat),
      Sorted (insertion_sort l).
  Proof.
    induction l as [| h t IH ].
    - simpl.
      unfold Sorted. 
      intros i j iv jv Hij Hi Hj.
      destruct i as [|i']. 
      simpl in Hi.
      + discriminate.
      + destruct j as [|j']. 
        * lia.
        * discriminate.
    - simpl. 
      apply insert_sorted.
      exact IH.
  Qed.

  End Exercice4.


  (*---------------------------- Exercice 5 ----------------------------*)

  Module Exercice5.
  Import Exercice1.
  Import Exercice2.
  Import Exercice3.
  Import Exercice4.

  Definition is_a_sorting_algorithm (f: list nat -> list nat): Prop :=
    forall (l: list nat),
      Permutation l (f l) /\ Sorted (f l).

  Lemma insertion_sort_is_a_sorting_algorithm:
    is_a_sorting_algorithm insertion_sort.
  Proof.
    unfold is_a_sorting_algorithm.
    intro l.
    split.
      - apply insertion_sort_perm.
      - apply insertion_sort_sorted.
  Qed.

  End Exercice5.

  (*---------------------------- Exercice 6 - Difficult ----------------------------*)

  Module Exercice6Difficult.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  Fixpoint list_max (l : list nat) :=
  match l with
  | [] => 0
  | x::xs => Nat.max x (list_max xs)
  end.

  (*---------------------------- Exercice 6.1 - Difficult ----------------------------*)

  Lemma bubble_pass_moves_max_to_tail:
    forall (a: nat) (l: list nat),
      exists (b: nat) (l': list nat),
        bubble_pass (a :: l) = l' ++ [b] /\ list_max (a :: l) = b.
  Proof.
    intros.
    revert a.
    induction l as [| x tl IH]; intros a; simpl.
    - exists a, [].
      split.
      + rewrite bubble_pass_equation. 
        simpl.
        reflexivity.
      + rewrite Nat.max_0_r. 
        reflexivity.
    - rewrite bubble_pass_equation.
      destruct tl as [| y tl'].
      + destruct (a <? x) eqn:Hax; simpl.
        * exists x, [a].
          split. 
            ++ rewrite bubble_pass_equation. 
               simpl.
               reflexivity.
            ++ rewrite Nat.max_0_r. 
               apply Nat.max_r. 
               apply Nat.ltb_lt in Hax.
               lia.
        * exists a, [x]. 
          split. 
            ++ rewrite bubble_pass_equation.
               simpl.
               reflexivity.
            ++ rewrite Nat.max_0_r. 
               apply Nat.max_l. 
               apply Nat.ltb_ge in Hax.
               exact Hax.
      + destruct (a <? x) eqn:Hax; simpl.
        * pose proof (IH x) as [b [l1 [Hbub Hmax]]].
          rewrite Hbub.
          exists b, (a :: l1).
          split.
              ++ simpl.
                 reflexivity.
              ++ replace (Nat.max x (Nat.max y (list_max tl')))
                 with (list_max (x :: y :: tl')) by (simpl; reflexivity).
                 rewrite Hmax. 
                 apply Nat.max_r.
                 assert (Hx_le_b : x <= b).
                 { rewrite <- Hmax. 
                   simpl. 
                   apply Nat.le_max_l.
                 } 
                 apply Nat.le_trans with (m := x).
                   -- apply Nat.lt_le_incl.
                      apply Nat.ltb_lt in Hax. 
                      exact Hax.
                   -- exact Hx_le_b.
        * pose proof (IH a) as [b [l1 [Hbub Hmax]]].
          rewrite Hbub. 
          exists b, (x :: l1). 
          split.
            ++ simpl.
               reflexivity.
            ++ apply Nat.ltb_ge in Hax.
               rewrite Nat.max_assoc.
               rewrite (Nat.max_l _ _ Hax).
               simpl in Hmax.
               exact Hmax.
  Qed.


  (*---------------------------- Exercice 6.2 - Difficult ----------------------------*)

  Lemma bubble_pass_snoc_aux:
    forall (a b: nat) (l: list nat),
      list_max (a :: l) <= b ->
        bubble_pass (a :: l ++ [b]) = bubble_pass (a :: l) ++ [b].
  Proof.
    intros a b l.
    revert a.
    induction l as [| z tl' IH]; intros a Hle; simpl.
    - rewrite bubble_pass_equation.
      destruct (a <? b) eqn:Hab; simpl.
      + rewrite bubble_pass_equation.
        rewrite bubble_pass_equation.
        simpl.
        reflexivity.
      + apply Nat.ltb_ge in Hab as Hba.
        assert (Ha_le : a <= b).
        {
          simpl in Hle.
          eapply Nat.le_trans.
          - apply Nat.le_max_l.
          - exact Hle.
        }
        apply Nat.le_antisymm in Ha_le. 
          * subst. 
            rewrite bubble_pass_equation. 
            simpl. 
            reflexivity.
          * exact Hba.
    - simpl in Hle.
      assert (Hle_ztl : list_max (z :: tl') <= b).
      {
        eapply Nat.le_trans.
          - apply Nat.le_max_r.
          - exact Hle.
      }
      assert (Ha_le : a <= b).
      {
        eapply Nat.le_trans.
          - apply Nat.le_max_l.
          - exact Hle.
      }
      assert (Hle_tl' : list_max tl' <= b).
      {
        eapply Nat.le_trans.
          - apply Nat.le_max_r.
          - exact Hle_ztl.
      }
      assert (Hle_a_tl' : list_max (a :: tl') <= b).
      { 
        simpl. 
        apply Nat.max_lub.
          - exact Ha_le.
          - exact Hle_tl'.
      }
      rewrite bubble_pass_equation.
      destruct (a <? z) eqn:Haz; simpl.
        + specialize (IH z Hle_ztl).
          rewrite IH.
          assert (Hhead : bubble_pass (a :: z :: tl') = a :: bubble_pass (z :: tl')).
          { 
            rewrite bubble_pass_equation. 
            rewrite Haz. 
            reflexivity. 
          }
          rewrite Hhead.
          simpl.
          reflexivity.
        + specialize (IH a Hle_a_tl').
          rewrite IH.
          assert (Hhead : bubble_pass (a :: z :: tl') = z :: bubble_pass (a :: tl')).
          { 
            rewrite bubble_pass_equation. 
            rewrite Haz. 
            reflexivity. 
          }
          rewrite Hhead.
          simpl.
          reflexivity.
  Qed.

  (*---------------------------- Exercice 6.3 - Difficult ----------------------------*)


  Lemma bubble_pass_snoc:
    forall (a: nat) (l: list nat),
      list_max l <= a ->
        bubble_pass (l ++ [a]) = bubble_pass l ++ [a].
  Proof.
    intros a l H.
    destruct l as [| x tl]; simpl.
    - rewrite bubble_pass_equation.
      rewrite bubble_pass_equation.
      simpl. 
      reflexivity.
    - apply bubble_pass_snoc_aux. 
      exact H.
  Qed.



  (*---------------------------- Exercice 6.4 - Difficult ----------------------------*)
  Lemma bubble_pass_snoc_cons_max :
    forall z tl, list_max (bubble_pass (z :: tl)) <= Nat.max z (list_max tl).
  Proof.
    intros z tl.
    revert z.
    induction tl as [| y tl IH]; intro z; simpl.
    - rewrite bubble_pass_equation.
      simpl. 
      lia.
    - rewrite bubble_pass_equation. 
      destruct (z <? y) eqn:Hz; simpl.
      + apply Nat.max_lub.
        * apply Nat.le_max_l.
        * specialize (IH y).
          eapply Nat.le_trans.
            ++ exact IH.
            ++ apply Nat.le_max_r.
      + apply Nat.max_lub.
        * eapply Nat.le_trans.
            ++ apply Nat.le_max_l. 
            ++ apply Nat.le_max_r.
        * specialize (IH z).
          eapply Nat.le_trans.
            ++ exact IH.
            ++ lia.
  Qed.

  Lemma bubble_pass_snoc_max :
    forall l, list_max (bubble_pass l) <= list_max l.
  Proof.
    destruct l as [|x tl]; simpl.
    - rewrite bubble_pass_equation. 
      simpl. 
      apply Nat.le_refl.
    - apply bubble_pass_snoc_cons_max.
  Qed.

  Lemma list_max_bubble_pass_snoc :
    forall n l, list_max (Nat.iter n bubble_pass l) <= list_max l.
  Proof.
    induction n as [|n IH]; intros l; simpl.
    - apply Nat.le_refl.
    - eapply Nat.le_trans.
      + apply bubble_pass_snoc_max.
      + apply IH.
  Qed.

  Lemma bubble_pass_snoc_iter:
    forall (a n: nat) (l: list nat),
      list_max l <= a ->
        Nat.iter n bubble_pass (l ++ [a]) = Nat.iter n bubble_pass l ++ [a].
  Proof.
    intros a n l Hle.
    induction n as [|n IH]; simpl.
    - reflexivity.
    - rewrite IH.
      apply bubble_pass_snoc.
      eapply Nat.le_trans.
        + apply list_max_bubble_pass_snoc.
        + exact Hle.
  Qed.


  End Exercice6Difficult.


