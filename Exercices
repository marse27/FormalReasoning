  From Coq Require Import Arith.PeanoNat. (* Required for nat *)
  From Coq Require Import Lists.List. (* Required for list *)
  From Coq Require Import micromega.Lia. (* Required for the 'lia' tactic *)
  From Coq Require Import funind.Recdef. (* Required for the 'function' definition *)
  From Coq Require Import Sorting.Permutation. (* Required for Permutation *)
  From Coq Require Import Sorting.Sorted. (* Required for StronglySorted *)
  Import ListNotations. (* Required for list notations *)

  (*---------------------------- Exercice 1 ----------------------------*)

  Module Exercice1.

  Fixpoint insert (n : nat) (l : list nat) : list nat :=
    match l with
    | [] => [n]
    | h :: t =>
        if Nat.leb n h
        then n :: l
        else h :: insert n t
    end.

  Fixpoint insertion_sort (l : list nat) : list nat :=
    match l with
    | [] => []
    | h :: t => insert h (insertion_sort t)
    end.

  Example sort_pi :
    insertion_sort [3; 1; 4; 1; 5; 9; 2; 6; 5; 3; 5]
    = [1; 1; 2; 3; 3; 4; 5; 5; 5; 6; 9].
  Proof. reflexivity. Qed.

  End Exercice1.

  (*---------------------------- Exercice 2 ----------------------------*)

  Module Exercice2.
  Import Exercice1.

  Lemma insert_perm :
    forall (a : nat) (l : list nat),
      Permutation (a :: l) (insert a l).
  Proof.
    induction l as [| h t IH]; simpl.
    - apply Permutation_refl.
    - destruct (Nat.leb a h) eqn:EH.
      + apply Permutation_refl.
      + eapply perm_trans.
        * apply perm_swap.
        * apply perm_skip. exact IH.
  Qed.

  Lemma insertion_sort_perm :
    forall (l : list nat),
      Permutation l (insertion_sort l).
  Proof.
    induction l as [| h t IH]; simpl.
    - apply Permutation_refl.
    - eapply perm_trans.
      + apply perm_skip. exact IH.
      + apply insert_perm.
  Qed.

  End Exercice2.

  (*---------------------------- Exercice 3 ----------------------------*)

  Module Exercice3.
  Import Exercice1.

  Definition Sorted (l: list nat): Prop :=
  forall (i j iv jv: nat),
    i < j ->
      nth_error l i = Some iv ->
        nth_error l j = Some jv ->
          iv <= jv.

  Lemma Sorted_cons_iff :
    forall (a : nat) (l : list nat),
      Sorted l /\ Forall (le a) l <-> Sorted (a :: l).
  Proof.
    split.
    - intros [Hs Hl]. unfold Sorted in *.
      intros i j iv jv Hij Hi Hj. simpl in Hi, Hj.
      destruct j as [| j']; [inversion Hij|].
      destruct i as [| i'].
      + inversion Hi; subst iv. simpl in Hj.
        eapply Forall_forall in Hl; [exact Hl|now apply nth_error_In in Hj].
      + assert (i' < j') by lia. eapply Hs; eauto.
    - intros H. split.
      + (* Sorted l *)
        unfold Sorted in *. intros i j iv jv Hij Hi Hj.
        assert (S i < S j) by lia.
        specialize (H (S i) (S j) iv jv H0).
        simpl in H. rewrite Hi in H; rewrite Hj in H.
        (* H now needs two trivial equalities *)
        apply H.
          * reflexivity.
          * reflexivity.
      + (* Forall (le a) l *)
        apply Forall_forall. intros x HIn.
        apply In_nth_error in HIn as [j' Hj'].
        unfold Sorted in H.
        specialize (H 0 (S j') a x ltac:(lia)).
        simpl in H. rewrite Hj' in H. apply H.
          * reflexivity.
          * reflexivity.
  Qed.
  End Exercice3.

  (*---------------------------- Exercice 4 ----------------------------*)

  Module Exercice4.
  Import Exercice1.
  Import Exercice3.

  (*---------------------------- Exercice 4.1 ----------------------------*)


Lemma Forall_le_trans :
  forall (l : list nat) (a x : nat),
    a <= x ->
    Forall (fun y => x <= y) l ->
    Forall (fun y => a <= y) l.
Proof.
  intros l a x Hax Hl.
  eapply Forall_impl; [|exact Hl].
  intros y Hy. eapply Nat.le_trans; [exact Hax| exact Hy].
Qed.

Lemma Forall_le_insert :
  forall x a l,
    Forall (fun z => x <= z) l ->
    x <= a ->
    Forall (fun z => x <= z) (insert a l).
Proof.
  intros x a l Hl Hxa; revert a Hxa.
  induction Hl as [|y ys Hy Hys IH]; intros a Hxa; simpl.
  - constructor; [assumption|constructor].
  - destruct (a <=? y) eqn:Hay.
    + constructor; [assumption|constructor; [exact Hy|exact Hys]].
    + constructor; [exact Hy|apply IH; exact Hxa].
Qed.

Lemma insert_sorted :
  forall (a : nat) (l : list nat),
    Sorted l ->
    Sorted (insert a l).
Proof.
  intros a l Hs; revert a.
  induction l as [|x xs IH]; intros a; simpl.
  - (* l = [] *)
    apply (proj1 (Sorted_cons_iff a [])).
    split; [exact Hs | constructor].
  - (* l = x :: xs *)
    destruct (a <=? x) eqn:Hab.
    + (* case: a <= x *)
      apply (proj1 (Sorted_cons_iff a (x :: xs))).
      split.
      -- exact Hs.
      -- constructor.
  ++ apply Nat.leb_le in Hab.  (* turns Hab into: Hab : a <= x *)
exact Hab.
  (* a <= x *)
  ++ (* need Forall (le a) xs *)
    destruct (proj2 (Sorted_cons_iff x xs) Hs) as [Hxs Hforx].
    (* Hforx : Forall (le x) xs *)
    eapply Forall_le_trans. apply Nat.leb_le in Hab. exact Hab. exact Hforx.

    + (* a goes into the tail *)
      apply Nat.leb_gt in Hab.  (* so x < a ⇒ x <= a *)
      apply (proj1 (Sorted_cons_iff x (insert a xs))).
      split.
      * (* tail is sorted by IH *)
        destruct (proj2 (Sorted_cons_iff x xs) Hs) as [Hxs _].
        apply IH, Hxs.
      * (* preserve head ≤ _ after insertion *)
        destruct (proj2 (Sorted_cons_iff x xs) Hs) as [_ Hforx].
        apply Forall_le_insert; [exact Hforx| lia ].
Qed.




  (*---------------------------- Exercice 4.1 - v2 -----------------------*)

  Lemma Forall_le_lift :
  forall a b l, a <= b -> Forall (le b) l -> Forall (le a) l.
  Proof.
    intros a b l Hab H.
    induction H.
    - constructor.
    - constructor.
      + eapply Nat.le_trans; [exact Hab|exact H].
      + exact IHForall.
  Qed.

  Lemma Forall_le_preserved_by_insert :
    forall h a t,
      Forall (le h) t ->
      h <= a ->
      Forall (le h) (insert a t).
  Proof.
    intros h a t Hfor Hha.
    induction Hfor as [|x xs Hhx Hfor' IH]; simpl.
    - constructor; [assumption|constructor].
    - destruct (Nat.leb a x) eqn:Habx.
      + (* a <= x, list becomes a :: x :: xs *)
        constructor; [assumption|].
        constructor.
        * eapply Nat.le_trans; [exact Hha|].
          apply Nat.leb_le in Habx; exact Habx.
        * exact Hfor'.
      + (* a > x, list becomes x :: insert a xs *)
        constructor; [assumption|].
        apply IH; assumption.
  Qed.

  Lemma insert_sorted :
    forall (a : nat) (l : list nat),
      Sorted l ->
      Sorted (insert a l).
  Proof.
    intros a l Hs.
    induction l as [|h t IH]; simpl.
    - (* base: [a] *)
      unfold Sorted. intros i j iv jv Hij Hi Hj.
      destruct i as [|i']; simpl in Hi.
      + inversion Hi; subst iv. destruct j as [|j']; [lia|].
        simpl in Hj. destruct j'; inversion Hj.
      + destruct j as [|j']; [lia|]. simpl in Hi. destruct i'; inversion Hi.
    - destruct (Nat.leb a h) eqn:Ha_le_h.
      + (* a <= h: a :: h :: t *)
        pose proof (proj2 (Sorted_cons_iff h t) Hs) as [Ht Hfor_h].
        pose proof (proj1 (Nat.leb_le a h) Ha_le_h) as Hah.  (* a <= h *)
        assert (Forall (le a) (h :: t)) as Hforall_a.
        { constructor.
          - exact Hah.
          - eapply Forall_le_lift; [exact Hah | exact Hfor_h]. }
        (* Use proj1 : (Sorted (h::t) /\ Forall (le a) (h::t)) -> Sorted (a::h::t) *)
        exact ((proj1 (Sorted_cons_iff a (h :: t))) (conj Hs Hforall_a)).
      + (* a > h: h :: insert a t *)
        pose proof (proj2 (Sorted_cons_iff h t) Hs) as [Ht Hfor_h].
        specialize (IH Ht).
        pose proof (proj1 (Nat.leb_gt a h) Ha_le_h) as Hagt.  (* h < a *)
        assert (Forall (le h) (insert a t)) as Hforall_h.
        { apply Forall_le_preserved_by_insert; [exact Hfor_h|].
          apply Nat.lt_le_incl; exact Hagt. }
        (* Again need pair -> Sorted (h :: insert a t) *)
        exact ((proj1 (Sorted_cons_iff h (insert a t))) (conj IH Hforall_h)).
  Qed.


  (*---------------------------- Exercice 4.2 ----------------------------*)

  Lemma insertion_sort_sorted :
    forall (l : list nat),
      Sorted (insertion_sort l).
  Proof.
    induction l as [| h t IH ]; simpl.
    - (* Sorted [] *)
      unfold Sorted. intros i j iv jv Hij Hi Hj.
      destruct i as [|i']; simpl in Hi.
      + (* i = 0 *) discriminate.
      + (* i = S i' *)
        destruct j as [|j']; [lia|].
        simpl in Hi. discriminate.
    - (* Sorted (insert h (insertion_sort t)) *)
      apply insert_sorted. exact IH.
  Qed.

  End Exercice4.


  (*---------------------------- Exercice 5 ----------------------------*)

  Module Exercice5.
  Import Exercice1.
  Import Exercice2.
  Import Exercice3.
  Import Exercice4.

  Definition is_a_sorting_algorithm (f: list nat -> list nat): Prop :=
    forall (l: list nat),
      Permutation l (f l) /\ Sorted (f l).

  Lemma insertion_sort_is_a_sorting_algorithm :
    is_a_sorting_algorithm insertion_sort.
  Proof.
    unfold is_a_sorting_algorithm.
    intro l.
    split.
    - apply insertion_sort_perm.
    - apply insertion_sort_sorted.
  Qed.

  End Exercice5.

  (*---------------------------- Exercice 6 - Moderate ----------------------------*)

  Module Exercice6Moderate.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  (*---------------------------- Exercice 6.1 - Moderate ----------------------------*)


  Lemma bubble_pass_perm :
    forall (l : list nat),
      Permutation l (bubble_pass l).
  Proof.
    intro l.
    functional induction (bubble_pass l) using bubble_pass_ind.
    - (* [] *) apply Permutation_refl.
    - (* [x] *) apply Permutation_refl.
    - (* x :: y :: l', with x <? y = true *)
      apply perm_skip.
      remember (y :: l') as r eqn:Hr. exact IHl0.
    - (* x :: y :: l', with x <? y = false *)
      eapply perm_trans.
      + apply perm_swap.
      + apply perm_skip. exact IHl0.
  Qed.

  (*---------------------------- Exercice 6.2 - Moderate ----------------------------*)

  Lemma bubble_pass_perm_iter :
    forall (n : nat) (l : list nat),
      Permutation l (Nat.iter n bubble_pass l).
  Proof.
    induction n as [| n IH]; intros l; simpl.
    - apply Permutation_refl.
    - eapply Permutation_trans.
      + apply IH.
      + apply bubble_pass_perm.
  Qed.

  (*---------------------------- Exercice 6.3 - Moderate ----------------------------*)

  Lemma bubble_sort_perm :
    forall (l : list nat),
      Permutation l (bubble_sort l).
  Proof.
    intros l.
    unfold bubble_sort.
    apply bubble_pass_perm_iter.
  Qed.

  End Exercice6Moderate.

  (*---------------------------- Exercice 6 - Hard ----------------------------*)

  Module Exercice6Hard.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  Fixpoint list_max (l : list nat) :=
  match l with
  | [] => 0
  | x::xs => Nat.max x (list_max xs)
  end.

  (*---------------------------- Exercice 6.1 - Hard ----------------------------*)

  Lemma bubble_pass_moves_max_to_tail :
    forall (a : nat) (l : list nat),
      exists (b : nat) (l' : list nat),
        bubble_pass (a :: l) = l' ++ [b] /\ list_max (a :: l) = b.
  Proof.
    intros.
    revert a.
    induction l as [| x tl IH]; intros a; simpl.
    - exists a, []. split.
      + rewrite bubble_pass_equation. reflexivity.
      + rewrite Nat.max_0_r. reflexivity.
    - rewrite bubble_pass_equation.
      destruct tl as [| y tl'].
      + destruct (a <? x) eqn:Hax; simpl.
        * exists x, [a]. split. rewrite bubble_pass_equation. reflexivity.
          rewrite Nat.max_0_r. apply Nat.max_r. apply Nat.ltb_lt in Hax; lia.
        * exists a, [x]. split. rewrite bubble_pass_equation. reflexivity.
          rewrite Nat.max_0_r. apply Nat.max_l. apply Nat.ltb_ge in Hax; lia.
      + destruct (a <? x) eqn:Hax; simpl.
        * pose proof (IH x) as [b [l1 [Hbub Hmax]]].
          rewrite Hbub. exists b, (a :: l1). split; [reflexivity|].
          replace (Nat.max x (Nat.max y (list_max tl')))
          with (list_max (x :: y :: tl')) by (simpl; reflexivity). rewrite Hmax. apply Nat.max_r.
          assert (Hx_le_b : x <= b).
          { rewrite <- Hmax. simpl. apply Nat.le_max_l. } 
          apply Nat.le_trans with (m := x).
            -- (* a ≤ x *)
              apply Nat.lt_le_incl.                (* turn < into ≤ *)
              apply Nat.ltb_lt in Hax; exact Hax.  (* from a<?x=true get a<x *)
            -- (* x ≤ b *)
              exact Hx_le_b.
        * pose proof (IH a) as [b [l1 [Hbub Hmax]]]. 
          rewrite Hbub. exists b, (x :: l1). split; [reflexivity|].
          apply Nat.ltb_ge in Hax.  (* Hax : x ≤ a *)
          (* reassociate so (Nat.max a x) appears, then kill it using x ≤ a *)
          rewrite Nat.max_assoc.
          rewrite (Nat.max_l _ _ Hax).  (* turns Nat.max a x into a *)
          (* Now the goal is exactly list_max (a :: y :: tl') = b *)
          simpl in Hmax. simpl in Hmax.  (* list_max (a::y::tl') ⇒ Nat.max a (Nat.max y (list_max tl')) *)
          exact Hmax.
  Qed.


  (*---------------------------- Exercice 6.2 - Hard ----------------------------*)

Lemma bubble_pass_snoc_aux :
  forall (a b: nat) (l: list nat),
    list_max (a :: l) <= b ->
    bubble_pass (a :: l ++ [b]) = bubble_pass (a :: l) ++ [b].
Proof.
  intros a b l.
  revert a.                                 (* ← generalize the head *)
  induction l as [| z tl' IH]; intros a Hle; simpl.
  - (* l = [] *)
    rewrite bubble_pass_equation.
    destruct (a <? b) eqn:Hab; simpl.
    + rewrite bubble_pass_equation. rewrite bubble_pass_equation.  reflexivity.
    + apply Nat.ltb_ge in Hab as Hba.       (* b <= a *)
      assert (Ha_le : a <= b)
        by (simpl in Hle; eapply Nat.le_trans; [apply Nat.le_max_l| exact Hle]).
      apply Nat.le_antisymm in Ha_le; [subst|exact Hba].
      rewrite bubble_pass_equation. reflexivity.
  - (* l = z :: tl' *)
    simpl in Hle.                            (* max a (max z (list_max tl')) <= b *)
    assert (Hle_ztl : list_max (z :: tl') <= b)
      by (eapply Nat.le_trans; [apply Nat.le_max_r| exact Hle]).
    assert (Ha_le : a <= b)
      by (eapply Nat.le_trans; [apply Nat.le_max_l| exact Hle]).
    assert (Hle_tl' : list_max tl' <= b)
      by (eapply Nat.le_trans; [apply Nat.le_max_r| exact Hle_ztl]).
    assert (Hle_a_tl' : list_max (a :: tl') <= b).
    { simpl. apply Nat.max_lub; [exact Ha_le| exact Hle_tl']. }

    rewrite bubble_pass_equation.
    destruct (a <? z) eqn:Haz; simpl.
    + (* then: a stays; recurse on (z :: tl') *)
    specialize (IH z Hle_ztl).
    rewrite IH.
    (* Normalize the RHS head-step using Haz = true *)
    assert (Hhead :
      bubble_pass (a :: z :: tl') = a :: bubble_pass (z :: tl')).
    { rewrite bubble_pass_equation. rewrite Haz. reflexivity. }
    rewrite Hhead.
    reflexivity.
    + (* else: z stays; recurse on (a :: tl') *)
    specialize (IH a Hle_a_tl').
    rewrite IH.
    (* Same trick on the LHS match, but for (a :: tl') *)
    (* Normalize RHS head-step with Haz = false *)
    assert (Hhead :
      bubble_pass (a :: z :: tl') = z :: bubble_pass (a :: tl')).
    { rewrite bubble_pass_equation. rewrite Haz. reflexivity. }
    rewrite Hhead.
    reflexivity.
Qed.

  (*---------------------------- Exercice 6.3 - Hard ----------------------------*)


Lemma bubble_pass_snoc :
  forall (a: nat) (l: list nat),
    list_max l <= a ->
    bubble_pass (l ++ [a]) = bubble_pass l ++ [a].
Proof.
  intros a l H.
  destruct l as [| x tl]; simpl.
  - (* l = [] *)
    rewrite bubble_pass_equation, bubble_pass_equation. reflexivity.
  - (* l = x :: tl *)
    (* reuse the auxiliary with head x, tail tl, bound a *)
    apply bubble_pass_snoc_aux. exact H.
Qed.



  (*---------------------------- Exercice 6.4 - Hard ----------------------------*)
(* Stronger helper with the right quantifiers: generalize z before inducting on tl *)
Lemma bubble_pass_cons_max_le :
  forall z tl, list_max (bubble_pass (z :: tl)) <= Nat.max z (list_max tl).
Proof.
  (* introduce both in the right order, then keep z generic during IH on tl *)
  intros z tl.
  revert z.
  induction tl as [| y tl IH]; intro z; simpl.
  - rewrite bubble_pass_equation. simpl. lia.
  - rewrite bubble_pass_equation. simpl.
    destruct (z <? y) eqn:Hz; simpl.
    + (* z :: bubble_pass (y :: tl) *)
      apply Nat.max_lub.
      * apply Nat.le_max_l.
      * specialize (IH y).                       (* <= max y (list_max tl) *)
        eapply Nat.le_trans; [exact IH|].
        apply Nat.le_max_r.                      (* lift into max z ... *)
    + (* y :: bubble_pass (z :: tl) *)
      apply Nat.max_lub.
      * eapply Nat.le_trans; [apply Nat.le_max_l|]. apply Nat.le_max_r.
      * specialize (IH z).                       (* <= max z (list_max tl) *)
        eapply Nat.le_trans; [exact IH|].
        lia.
Qed.


(* One-liner corollary *)
Lemma bubble_pass_max_le :
  forall l, list_max (bubble_pass l) <= list_max l.
Proof.
  destruct l as [|x tl]; simpl.
  - rewrite bubble_pass_equation. simpl. apply Nat.le_refl.
  - apply bubble_pass_cons_max_le.
Qed.

Lemma list_max_iter_bubble_pass_le :
  forall n l, list_max (Nat.iter n bubble_pass l) <= list_max l.
Proof.
  induction n as [|n IH]; intros l; simpl.
  - apply Nat.le_refl.
  - eapply Nat.le_trans; [apply bubble_pass_max_le|apply IH].
Qed.

Lemma bubble_pass_snoc_iter :
  forall (a n: nat) (l: list nat),
    list_max l <= a ->
    Nat.iter n bubble_pass (l ++ [a]) = Nat.iter n bubble_pass l ++ [a].
Proof.
  intros a n l Hle.
  induction n as [|n IH]; simpl.
  - reflexivity.
  - rewrite IH.
    apply bubble_pass_snoc.
    eapply Nat.le_trans; [apply list_max_iter_bubble_pass_le|exact Hle].
Qed.


  End Exercice6Hard.


  (*---------------------------- Exercice 6 - Very Hard ----------------------------*)

  Module Exercice6VeryHard.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
  match l with
    | [] => []
    | [x] => [x]
    | x :: y :: l' =>
      if x <? y then
        x :: bubble_pass (y :: l')
      else
        y :: bubble_pass (x :: l')
  end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  (*---------------------------- Exercice 6.1 - Very Hard ----------------------------*)


  Lemma SSorted_snoc:
    forall {T: Type} (R: T -> T -> Prop) (t: T) (l: list T),
      StronglySorted R l ->
        Forall (fun (x: T) => R x t) l ->
          StronglySorted R (l ++ [t]).
  Proof.
    intros T R t l Hss.
    revert t.
    induction Hss as [| a l' Hss IH Hall]; intros t Ht; simpl.
    - (* l = [] *)
      constructor. constructor. constructor.
    - (* l = a :: l' *)
      inversion Ht as [| ? ? Hat Ht']; subst.
      constructor.
      + (* tail stays strongly sorted *)
        apply IH. exact Ht'.
      + (* every element in tail is <= a, and also a <= t *)
        apply Forall_app; split.
        * exact Hall.
        * constructor; [exact Hat | constructor].
  Qed.

  (*---------------------------- Exercice 6.2 - Very Hard ----------------------------*)

  End Exercice6VeryHard

