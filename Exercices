  From Coq Require Import Arith.PeanoNat. (* Required for nat *)
  From Coq Require Import Lists.List. (* Required for list *)
  From Coq Require Import micromega.Lia. (* Required for the 'lia' tactic *)
  From Coq Require Import funind.Recdef. (* Required for the 'function' definition *)
  From Coq Require Import Sorting.Permutation. (* Required for Permutation *)
  From Coq Require Import Sorting.Sorted. (* Required for StronglySorted *)
  Import ListNotations. (* Required for list notations *)

  (*---------------------------- Exercice 1 ----------------------------*)

  Module Exercice1.

  Fixpoint insert (n : nat) (l : list nat) : list nat :=
    match l with
    | [] => [n]
    | h :: t =>
        if Nat.leb n h
        then n :: l
        else h :: insert n t
    end.

  Fixpoint insertion_sort (l : list nat) : list nat :=
    match l with
    | [] => []
    | h :: t => insert h (insertion_sort t)
    end.

  Example sort_pi :
    insertion_sort [3; 1; 4; 1; 5; 9; 2; 6; 5; 3; 5]
    = [1; 1; 2; 3; 3; 4; 5; 5; 5; 6; 9].
  Proof. reflexivity. Qed.

  End Exercice1.

  (*---------------------------- Exercice 2 ----------------------------*)

  Module Exercice2.
  Import Exercice1.

  Lemma insert_perm :
    forall (a : nat) (l : list nat),
      Permutation (a :: l) (insert a l).
  Proof.
    induction l as [| h t IH]; simpl.
    - apply Permutation_refl.
    - destruct (Nat.leb a h) eqn:EH.
      + apply Permutation_refl.
      + eapply perm_trans.
        * apply perm_swap.
        * apply perm_skip. exact IH.
  Qed.

  Lemma insertion_sort_perm :
    forall (l : list nat),
      Permutation l (insertion_sort l).
  Proof.
    induction l as [| h t IH]; simpl.
    - apply Permutation_refl.
    - eapply perm_trans.
      + apply perm_skip. exact IH.
      + apply insert_perm.
  Qed.

  End Exercice2.

  (*---------------------------- Exercice 3 ----------------------------*)

  Module Exercice3.
  Import Exercice1.

  Definition Sorted (l: list nat): Prop :=
  forall (i j iv jv: nat),
    i < j ->
      nth_error l i = Some iv ->
        nth_error l j = Some jv ->
          iv <= jv.

  Lemma Sorted_cons_iff :
    forall (a : nat) (l : list nat),
      Sorted l /\ Forall (le a) l <-> Sorted (a :: l).
  Proof.
    split.
    - intros [Hs Hl]. unfold Sorted in *.
      intros i j iv jv Hij Hi Hj. simpl in Hi, Hj.
      destruct j as [| j']; [inversion Hij|].
      destruct i as [| i'].
      + inversion Hi; subst iv. simpl in Hj.
        eapply Forall_forall in Hl; [exact Hl|now apply nth_error_In in Hj].
      + assert (i' < j') by lia. eapply Hs; eauto.
    - intros H. split.
      + (* Sorted l *)
        unfold Sorted in *. intros i j iv jv Hij Hi Hj.
        assert (S i < S j) by lia.
        specialize (H (S i) (S j) iv jv H0).
        simpl in H. rewrite Hi in H; rewrite Hj in H.
        (* H now needs two trivial equalities *)
        apply H.
          * reflexivity.
          * reflexivity.
      + (* Forall (le a) l *)
        apply Forall_forall. intros x HIn.
        apply In_nth_error in HIn as [j' Hj'].
        unfold Sorted in H.
        specialize (H 0 (S j') a x ltac:(lia)).
        simpl in H. rewrite Hj' in H. apply H.
          * reflexivity.
          * reflexivity.
  Qed.
  End Exercice3.

  (*---------------------------- Exercice 4 ----------------------------*)

  Module Exercice4.
  Import Exercice1.
  Import Exercice3.

  (*---------------------------- Exercice 4.1 ----------------------------*)

  Lemma Forall_le_lift :
  forall a b l, a <= b -> Forall (le b) l -> Forall (le a) l.
  Proof.
    intros a b l Hab H.
    induction H.
    - constructor.
    - constructor.
      + eapply Nat.le_trans; [exact Hab|exact H].
      + exact IHForall.
  Qed.

  Lemma Forall_le_preserved_by_insert :
    forall h a t,
      Forall (le h) t ->
      h <= a ->
      Forall (le h) (insert a t).
  Proof.
    intros h a t Hfor Hha.
    induction Hfor as [|x xs Hhx Hfor' IH]; simpl.
    - constructor; [assumption|constructor].
    - destruct (Nat.leb a x) eqn:Habx.
      + (* a <= x, list becomes a :: x :: xs *)
        constructor; [assumption|].
        constructor.
        * eapply Nat.le_trans; [exact Hha|].
          apply Nat.leb_le in Habx; exact Habx.
        * exact Hfor'.
      + (* a > x, list becomes x :: insert a xs *)
        constructor; [assumption|].
        apply IH; assumption.
  Qed.

  Lemma insert_sorted :
    forall (a : nat) (l : list nat),
      Sorted l ->
      Sorted (insert a l).
  Proof.
    intros a l Hs.
    induction l as [|h t IH]; simpl.
    - (* base: [a] *)
      unfold Sorted. intros i j iv jv Hij Hi Hj.
      destruct i as [|i']; simpl in Hi.
      + inversion Hi; subst iv. destruct j as [|j']; [lia|].
        simpl in Hj. destruct j'; inversion Hj.
      + destruct j as [|j']; [lia|]. simpl in Hi. destruct i'; inversion Hi.
    - destruct (Nat.leb a h) eqn:Ha_le_h.
      + (* a <= h: a :: h :: t *)
        pose proof (proj2 (Sorted_cons_iff h t) Hs) as [Ht Hfor_h].
        pose proof (proj1 (Nat.leb_le a h) Ha_le_h) as Hah.  (* a <= h *)
        assert (Forall (le a) (h :: t)) as Hforall_a.
        { constructor.
          - exact Hah.
          - eapply Forall_le_lift; [exact Hah | exact Hfor_h]. }
        (* Use proj1 : (Sorted (h::t) /\ Forall (le a) (h::t)) -> Sorted (a::h::t) *)
        exact ((proj1 (Sorted_cons_iff a (h :: t))) (conj Hs Hforall_a)).
      + (* a > h: h :: insert a t *)
        pose proof (proj2 (Sorted_cons_iff h t) Hs) as [Ht Hfor_h].
        specialize (IH Ht).
        pose proof (proj1 (Nat.leb_gt a h) Ha_le_h) as Hagt.  (* h < a *)
        assert (Forall (le h) (insert a t)) as Hforall_h.
        { apply Forall_le_preserved_by_insert; [exact Hfor_h|].
          apply Nat.lt_le_incl; exact Hagt. }
        (* Again need pair -> Sorted (h :: insert a t) *)
        exact ((proj1 (Sorted_cons_iff h (insert a t))) (conj IH Hforall_h)).
  Qed.


  (*---------------------------- Exercice 4.2 ----------------------------*)

  Lemma insertion_sort_sorted :
    forall (l : list nat),
      Sorted (insertion_sort l).
  Proof.
    induction l as [| h t IH ]; simpl.
    - (* Sorted [] *)
      unfold Sorted. intros i j iv jv Hij Hi Hj.
      destruct i as [|i']; simpl in Hi.
      + (* i = 0 *) discriminate.
      + (* i = S i' *)
        destruct j as [|j']; [lia|].
        simpl in Hi. discriminate.
    - (* Sorted (insert h (insertion_sort t)) *)
      apply insert_sorted. exact IH.
  Qed.

  End Exercice4.


  (*---------------------------- Exercice 5 ----------------------------*)

  Module Exercice5.
  Import Exercice1.
  Import Exercice2.
  Import Exercice3.
  Import Exercice4.

  Definition is_a_sorting_algorithm (f: list nat -> list nat): Prop :=
    forall (l: list nat),
      Permutation l (f l) /\ Sorted (f l).

  Lemma insertion_sort_is_a_sorting_algorithm :
    is_a_sorting_algorithm insertion_sort.
  Proof.
    unfold is_a_sorting_algorithm.
    intro l.
    split.
    - apply insertion_sort_perm.
    - apply insertion_sort_sorted.
  Qed.

  End Exercice5.

  (*---------------------------- Exercice 6 - Moderate ----------------------------*)

  Module Exercice6Moderate.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  (*---------------------------- Exercice 6.1 - Moderate ----------------------------*)


  Lemma bubble_pass_perm :
    forall (l : list nat),
      Permutation l (bubble_pass l).
  Proof.
    intro l.
    functional induction (bubble_pass l) using bubble_pass_ind.
    - (* [] *) apply Permutation_refl.
    - (* [x] *) apply Permutation_refl.
    - (* x :: y :: l', with x <? y = true *)
      apply perm_skip.
      remember (y :: l') as r eqn:Hr. exact IHl0.
    - (* x :: y :: l', with x <? y = false *)
      eapply perm_trans.
      + apply perm_swap.
      + apply perm_skip. exact IHl0.
  Qed.

  (*---------------------------- Exercice 6.2 - Moderate ----------------------------*)

  Lemma bubble_pass_perm_iter :
    forall (n : nat) (l : list nat),
      Permutation l (Nat.iter n bubble_pass l).
  Proof.
    induction n as [| n IH]; intros l; simpl.
    - apply Permutation_refl.
    - eapply Permutation_trans.
      + apply IH.
      + apply bubble_pass_perm.
  Qed.

  (*---------------------------- Exercice 6.3 - Moderate ----------------------------*)

  Lemma bubble_sort_perm :
    forall (l : list nat),
      Permutation l (bubble_sort l).
  Proof.
    intros l.
    unfold bubble_sort.
    apply bubble_pass_perm_iter.
  Qed.

  End Exercice6Moderate.

  (*---------------------------- Exercice 6 - Hard ----------------------------*)

  Module Exercice6Hard.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  Fixpoint list_max (l : list nat) :=
  match l with
  | [] => 0
  | x::xs => Nat.max x (list_max xs)
  end.

  (*---------------------------- Exercice 6.1 - Hard ----------------------------*)

  Lemma bubble_pass_moves_max_to_tail :
    forall (a : nat) (l : list nat),
      exists (b : nat) (l' : list nat),
        bubble_pass (a :: l) = l' ++ [b] /\ list_max (a :: l) = b.
  Proof.
    intros.
    revert a.
    induction l as [| x tl IH]; intros a; simpl.
    - exists a, []. split.
      + rewrite bubble_pass_equation. reflexivity.
      + rewrite Nat.max_0_r. reflexivity.
    - rewrite bubble_pass_equation.
      destruct tl as [| y tl'].
      + destruct (a <? x) eqn:Hax; simpl.
        * exists x, [a]. split. rewrite bubble_pass_equation. reflexivity.
          rewrite Nat.max_0_r. apply Nat.max_r. apply Nat.ltb_lt in Hax; lia.
        * exists a, [x]. split. rewrite bubble_pass_equation. reflexivity.
          rewrite Nat.max_0_r. apply Nat.max_l. apply Nat.ltb_ge in Hax; lia.
      + destruct (a <? x) eqn:Hax; simpl.
        * pose proof (IH x) as [b [l1 [Hbub Hmax]]].
          rewrite Hbub. exists b, (a :: l1). split; [reflexivity|].
          replace (Nat.max x (Nat.max y (list_max tl')))
          with (list_max (x :: y :: tl')) by (simpl; reflexivity). rewrite Hmax. apply Nat.max_r.
          assert (Hx_le_b : x <= b).
          { rewrite <- Hmax. simpl. apply Nat.le_max_l. } 
          apply Nat.le_trans with (m := x).
            -- (* a ≤ x *)
              apply Nat.lt_le_incl.                (* turn < into ≤ *)
              apply Nat.ltb_lt in Hax; exact Hax.  (* from a<?x=true get a<x *)
            -- (* x ≤ b *)
              exact Hx_le_b.
        * pose proof (IH a) as [b [l1 [Hbub Hmax]]]. 
          rewrite Hbub. exists b, (x :: l1). split; [reflexivity|].
          apply Nat.ltb_ge in Hax.  (* Hax : x ≤ a *)
          (* reassociate so (Nat.max a x) appears, then kill it using x ≤ a *)
          rewrite Nat.max_assoc.
          rewrite (Nat.max_l _ _ Hax).  (* turns Nat.max a x into a *)
          (* Now the goal is exactly list_max (a :: y :: tl') = b *)
          simpl in Hmax. simpl in Hmax.  (* list_max (a::y::tl') ⇒ Nat.max a (Nat.max y (list_max tl')) *)
          exact Hmax.
  Qed.


  (*---------------------------- Exercice 6.2 - Hard ----------------------------*)

Lemma bubble_pass_snoc_aux_strict :
  forall (a b: nat) (l: list nat),
    list_max (a :: l) < b ->
    bubble_pass (a :: l ++ [b]) = bubble_pass (a :: l) ++ [b].
Proof.
  intros a b l Hlt.
  revert a b Hlt.
  induction l as [| x tl IH]; intros a b Hlt; simpl in *.
  - (* l = [] *)
    (* list_max [a] = a, so a < b *)
    rewrite bubble_pass_equation.
    destruct (a <? b) eqn:Hab.
    + rewrite bubble_pass_equation. rewrite bubble_pass_equation. reflexivity.
    + apply Nat.ltb_ge in Hab; lia. 
  - (* l = x :: tl *)
    rewrite bubble_pass_equation.
    destruct tl as [| y tl'].
    + (* derive a < b *)
      assert (Hab : a < b) by
        (eapply Nat.le_lt_trans; [apply Nat.le_max_l | exact Hlt]).

      (* derive x < b *)
      assert (Hxb : x < b).
      { eapply Nat.le_lt_trans.
        - (* x <= max a (max x (list_max [])) *)
          eapply Nat.le_trans.
          + (* x <= max x (list_max []) *)
            apply Nat.le_max_l.
          + (* max x (list_max []) <= max a (max x (list_max [])) *)
            apply Nat.le_max_r.
        - exact Hlt.
      }
      (* tl = [] branch *)
      (* tl = [] branch *)
      rewrite bubble_pass_equation.
      rewrite app_nil_l.                 (* [] ++ [b] -> [b] *)
      rewrite !bubble_pass_equation.

      destruct (a <? x) eqn:HaX.
      -- (* a < x *)
        apply Nat.ltb_lt in Hxb.         (* x <? b = true *)
        apply Nat.ltb_lt in Hab.         (* a <? b = true *)
        simpl. rewrite Hxb. reflexivity.
      -- (* a >= x *)
        apply Nat.ltb_lt in Hab.         (* a <? b = true *)
        simpl. rewrite Hab. reflexivity.

    + (* general case: x :: y :: tl' *)
      destruct (a <? x) eqn:HaX.
      *  rewrite bubble_pass_equation. simpl.

  (* fold the big match back so IH matches *)
  replace (match (y :: tl') ++ [b] with
           | [] => [x]
           | y0 :: l' =>
               if x <? y0 then x :: bubble_pass (y0 :: l')
               else y0 :: bubble_pass (x :: l')
           end)
    with (bubble_pass (x :: (y :: tl') ++ [b]))
    by (rewrite bubble_pass_equation; reflexivity).

  (* IH at a := x and the same b *)
  assert (Hltx : Nat.max x (list_max (y :: tl')) < b)
    by (eapply Nat.le_lt_trans; [apply Nat.le_max_r | exact Hlt]).
  pose proof (IH x b Hltx) as IHxEq.
  replace (if x <? y then x :: bubble_pass (y :: tl' ++ [b])
        else y :: bubble_pass (x :: tl' ++ [b]))
  with (bubble_pass (x :: (y :: tl') ++ [b]))
  by (rewrite bubble_pass_equation; reflexivity).

(* Goal is now: a :: bubble_pass (x :: (y :: tl') ++ [b]) = bubble_pass (a :: x :: y :: tl') ++ [b] *)

(* 2) Rewrite inside the cons using IHxEq *)
rewrite IHxEq.
(* LHS becomes: a :: (bubble_pass (x :: y :: tl') ++ [b]) *)

(* 3) Expose the same head-step on the RHS WITHOUT rewriting HaX in the goal *)
assert (Hhead :
  bubble_pass (a :: x :: y :: tl') = a :: bubble_pass (x :: y :: tl'))
  by (rewrite bubble_pass_equation; destruct (a <? x); [reflexivity|congruence]).
rewrite Hhead.

(* 4) Finish with the usual associativity trick *)
rewrite app_comm_cons. reflexivity.
   * rewrite bubble_pass_equation. simpl.

  (* fold the big match back so IH matches *)
  replace (match (y :: tl') ++ [b] with
           | [] => [a]
           | y0 :: l' =>
               if a <? y0 then a :: bubble_pass (y0 :: l')
               else y0 :: bubble_pass (a :: l')
           end)
    with (bubble_pass (a :: (y :: tl') ++ [b]))
    by (rewrite bubble_pass_equation; reflexivity).

  (* from a <? x = false get x <= a and drop x from max *)
  apply Nat.ltb_ge in HaX as Hge.  (* x <= a *)
  assert (HltA : Nat.max a (list_max (y :: tl')) < b).
  { simpl in Hlt. rewrite Nat.max_assoc in Hlt.
    rewrite (Nat.max_l _ _ Hge) in Hlt. exact Hlt. }

  (* IH at a := a and the same b *)
  pose proof (IH a b HltA) as IHaEq.
  replace (if a <? y then a :: bubble_pass (y :: tl' ++ [b])
        else y :: bubble_pass (a :: tl' ++ [b]))
  with (bubble_pass (a :: (y :: tl') ++ [b]))
  by (rewrite bubble_pass_equation; reflexivity).

(* derive x <= a from HaX=false, drop x from the outer max to build IH a b premise, apply IH *)

(* normalize RHS head without rewriting HaX *)
assert (Hhead' :
  bubble_pass (a :: x :: y :: tl') = x :: bubble_pass (a :: y :: tl'))
  by (rewrite bubble_pass_equation; destruct (a <? x); [congruence|reflexivity]).
rewrite Hhead'. rewrite IHaEq.

rewrite <- app_comm_cons.
(* now the goal is: x :: bubble_pass ((a :: y :: tl') ++ [b])
                     = x :: (bubble_pass (a :: y :: tl') ++ [b]) *)

(* rewrite the tail with your IH result *)

reflexivity.


Qed.

  (*---------------------------- Exercice 6.3 - Hard ----------------------------*)


Lemma bubble_pass_snoc :
  forall (a: nat) (l: list nat),
    list_max l <= a ->
    bubble_pass (l ++ [a]) = bubble_pass l ++ [a].
Proof.
  intros a l Hle.
  revert a Hle.
  induction l as [| x tl IH]; intros a Hle; simpl.
  - (* l = [] *)
    rewrite bubble_pass_equation. rewrite bubble_pass_equation. reflexivity.
  - destruct tl as [| y tl']; simpl in *.
    + (* l = [x] *)
      rewrite bubble_pass_equation.          (* bubble_pass [x; a] *)
      destruct (x <? a) eqn:Hxa; simpl.
      * rewrite bubble_pass_equation.  rewrite bubble_pass_equation. reflexivity.
      * (* x <? a = false ⇒ a <= x, and from Hle we also get x <= a *)
  apply Nat.ltb_ge in Hxa as Hax.            (* Hax : a <= x *)
  assert (Hxle : x <= a)
    by (eapply Nat.le_trans; [apply Nat.le_max_l | exact Hle]).
  assert (Hx_eq : x = a)
    by (apply Nat.le_antisymm; [exact Hxle | exact Hax]).
  subst. rewrite bubble_pass_equation. reflexivity.
    + (* l = x :: y :: tl' *)
      (* From max x (max y (list_max tl')) <= a, derive:
         - list_max (y :: tl') <= a
         - list_max (x :: tl') <= a *)
      assert (Hle_ytl : list_max (y :: tl') <= a).
      { eapply Nat.le_trans; [apply Nat.le_max_r|exact Hle]. }
      assert (Hle_tl : list_max tl' <= a).
      { eapply Nat.le_trans; [apply Nat.le_max_r|exact Hle_ytl]. }
      assert (Hx_le : x <= a).
      { eapply Nat.le_trans; [apply Nat.le_max_l|exact Hle]. }
      assert (Hle_xtl : list_max (x :: tl') <= a).
      { simpl. apply Nat.max_lub; [exact Hx_le|exact Hle_tl]. }

      (* Unfold one bubble step on both sides and align by the same guard *)
      rewrite bubble_pass_equation.
      destruct (x <? y) eqn:Hxy; simpl.
      * (* then-branch: x stays, recurse on (y :: tl') *)
        specialize (IH a Hle_ytl).
        rewrite IH.                          (* bubble_pass (y :: tl' ++ [a]) *)
        (* move ++[a] out of the cons, match RHS shape *)
        rewrite bubble_pass_equation. 
        (* fold the big match back so we can actually reason *)
replace (match tl' with
         | [] => [y]
         | y0 :: l' =>
             if y <? y0 then y :: bubble_pass (y0 :: l')
             else y0 :: bubble_pass (y :: l')
         end)
  with (bubble_pass (y :: tl'))
  by (rewrite bubble_pass_equation; reflexivity).

(* put ++ [a] outside the cons on the LHS *)
rewrite -> app_comm_cons.
(* LHS is now: (x :: bubble_pass (y :: tl')) ++ [a] *)

(* expose the head-step on the RHS WITHOUT rewriting Hxy in the goal *)
assert (Hhead :
  bubble_pass (x :: y :: tl') = x :: bubble_pass (y :: tl'))
  by (rewrite bubble_pass_equation;
      destruct (x <? y) eqn:E; [reflexivity | congruence]).  (* uses Hxy *)

rewrite Hhead.
reflexivity.

      * 
        assert (Hhead' :
          bubble_pass (x :: y :: tl') = y :: bubble_pass (x :: tl')).
        { rewrite bubble_pass_equation.
          destruct (x <? y); [congruence|reflexivity]. }
        rewrite Hhead'.

        (* 4) Reassociate to line up the ++ [a] tail. *)
        rewrite <- app_comm_cons. apply f_equal. admit.


Admitted.

  (*---------------------------- Exercice 6.4 - Hard ----------------------------*)
(* Stronger helper with the right quantifiers: generalize z before inducting on tl *)
Lemma bubble_pass_cons_max_le :
  forall z tl, list_max (bubble_pass (z :: tl)) <= Nat.max z (list_max tl).
Proof.
  (* introduce both in the right order, then keep z generic during IH on tl *)
  intros z tl.
  revert z.
  induction tl as [| y tl IH]; intro z; simpl.
  - rewrite bubble_pass_equation. simpl. lia.
  - rewrite bubble_pass_equation. simpl.
    destruct (z <? y) eqn:Hz; simpl.
    + (* z :: bubble_pass (y :: tl) *)
      apply Nat.max_lub.
      * apply Nat.le_max_l.
      * specialize (IH y).                       (* <= max y (list_max tl) *)
        eapply Nat.le_trans; [exact IH|].
        apply Nat.le_max_r.                      (* lift into max z ... *)
    + (* y :: bubble_pass (z :: tl) *)
      apply Nat.max_lub.
      * eapply Nat.le_trans; [apply Nat.le_max_l|]. apply Nat.le_max_r.
      * specialize (IH z).                       (* <= max z (list_max tl) *)
        eapply Nat.le_trans; [exact IH|].
        lia.
Qed.



(* One-liner corollary *)
Lemma bubble_pass_max_le :
  forall l, list_max (bubble_pass l) <= list_max l.
Proof.
  destruct l as [|x tl]; simpl.
  - rewrite bubble_pass_equation. simpl. apply Nat.le_refl.
  - apply bubble_pass_cons_max_le.
Qed.

Lemma list_max_iter_bubble_pass_le :
  forall n l, list_max (Nat.iter n bubble_pass l) <= list_max l.
Proof.
  induction n as [|n IH]; intros l; simpl.
  - apply Nat.le_refl.
  - eapply Nat.le_trans; [apply bubble_pass_max_le|apply IH].
Qed.

Lemma bubble_pass_snoc_iter :
  forall (a n: nat) (l: list nat),
    list_max l <= a ->
    Nat.iter n bubble_pass (l ++ [a]) = Nat.iter n bubble_pass l ++ [a].
Proof.
  intros a n l Hle.
  induction n as [|n IH]; simpl.
  - reflexivity.
  - rewrite IH.
    apply bubble_pass_snoc.
    eapply Nat.le_trans; [apply list_max_iter_bubble_pass_le|exact Hle].
Qed.





  End Exercice6Hard.


