  From Coq Require Import Arith.PeanoNat. (* Required for nat *)
  From Coq Require Import Lists.List. (* Required for list *)
  From Coq Require Import micromega.Lia. (* Required for the 'lia' tactic *)
  From Coq Require Import funind.Recdef. (* Required for the 'function' definition *)
  From Coq Require Import Sorting.Permutation. (* Required for Permutation *)
  From Coq Require Import Sorting.Sorted. (* Required for StronglySorted *)
  Import ListNotations. (* Required for list notations *)

  (*---------------------------- Exercice 1 ----------------------------*)

  Module Exercice1.

  Fixpoint insert (n : nat) (l : list nat) : list nat :=
    match l with
    | [] => [n]
    | h :: t =>
        if Nat.leb n h
        then n :: l
        else h :: insert n t
    end.

  Fixpoint insertion_sort (l : list nat) : list nat :=
    match l with
    | [] => []
    | h :: t => insert h (insertion_sort t)
    end.

  Example sort_pi :
    insertion_sort [3; 1; 4; 1; 5; 9; 2; 6; 5; 3; 5]
    = [1; 1; 2; 3; 3; 4; 5; 5; 5; 6; 9].
  Proof. reflexivity. Qed.

  End Exercice1.

  (*---------------------------- Exercice 2 ----------------------------*)

  Module Exercice2.
  Import Exercice1.

  Lemma insert_perm :
    forall (a : nat) (l : list nat),
      Permutation (a :: l) (insert a l).
  Proof.
    induction l as [| h t IH]; simpl.
    - apply Permutation_refl.
    - destruct (Nat.leb a h) eqn:EH.
      + apply Permutation_refl.
      + eapply perm_trans.
        * apply perm_swap.
        * apply perm_skip. exact IH.
  Qed.

  Lemma insertion_sort_perm :
    forall (l : list nat),
      Permutation l (insertion_sort l).
  Proof.
    induction l as [| h t IH]; simpl.
    - apply Permutation_refl.
    - eapply perm_trans.
      + apply perm_skip. exact IH.
      + apply insert_perm.
  Qed.

  End Exercice2.

  (*---------------------------- Exercice 3 ----------------------------*)

  Module Exercice3.
  Import Exercice1.

  Definition Sorted (l: list nat): Prop :=
  forall (i j iv jv: nat),
    i < j ->
      nth_error l i = Some iv ->
        nth_error l j = Some jv ->
          iv <= jv.

  Lemma Sorted_cons_iff :
    forall (a : nat) (l : list nat),
      Sorted l /\ Forall (le a) l <-> Sorted (a :: l).
  Proof.
    split.
    - intros [Hs Hl]. unfold Sorted in *.
      intros i j iv jv Hij Hi Hj. simpl in Hi, Hj.
      destruct j as [| j']; [inversion Hij|].
      destruct i as [| i'].
      + inversion Hi; subst iv. simpl in Hj.
        eapply Forall_forall in Hl; [exact Hl|now apply nth_error_In in Hj].
      + assert (i' < j') by lia. eapply Hs; eauto.
    - intros H. split.
      + (* Sorted l *)
        unfold Sorted in *. intros i j iv jv Hij Hi Hj.
        assert (S i < S j) by lia.
        specialize (H (S i) (S j) iv jv H0).
        simpl in H. rewrite Hi in H; rewrite Hj in H.
        (* H now needs two trivial equalities *)
        apply H.
          * reflexivity.
          * reflexivity.
      + (* Forall (le a) l *)
        apply Forall_forall. intros x HIn.
        apply In_nth_error in HIn as [j' Hj'].
        unfold Sorted in H.
        specialize (H 0 (S j') a x ltac:(lia)).
        simpl in H. rewrite Hj' in H. apply H.
          * reflexivity.
          * reflexivity.
  Qed.
  End Exercice3.

  (*---------------------------- Exercice 4 ----------------------------*)

  Module Exercice4.
  Import Exercice1.
  Import Exercice3.

  (*---------------------------- Exercice 4.1 ----------------------------*)

  Lemma Forall_le_lift :
  forall a b l, a <= b -> Forall (le b) l -> Forall (le a) l.
  Proof.
    intros a b l Hab H.
    induction H.
    - constructor.
    - constructor.
      + eapply Nat.le_trans; [exact Hab|exact H].
      + exact IHForall.
  Qed.

  Lemma Forall_le_preserved_by_insert :
    forall h a t,
      Forall (le h) t ->
      h <= a ->
      Forall (le h) (insert a t).
  Proof.
    intros h a t Hfor Hha.
    induction Hfor as [|x xs Hhx Hfor' IH]; simpl.
    - constructor; [assumption|constructor].
    - destruct (Nat.leb a x) eqn:Habx.
      + (* a <= x, list becomes a :: x :: xs *)
        constructor; [assumption|].
        constructor.
        * eapply Nat.le_trans; [exact Hha|].
          apply Nat.leb_le in Habx; exact Habx.
        * exact Hfor'.
      + (* a > x, list becomes x :: insert a xs *)
        constructor; [assumption|].
        apply IH; assumption.
  Qed.

  Lemma insert_sorted :
    forall (a : nat) (l : list nat),
      Sorted l ->
      Sorted (insert a l).
  Proof.
    intros a l Hs.
    induction l as [|h t IH]; simpl.
    - (* base: [a] *)
      unfold Sorted. intros i j iv jv Hij Hi Hj.
      destruct i as [|i']; simpl in Hi.
      + inversion Hi; subst iv. destruct j as [|j']; [lia|].
        simpl in Hj. destruct j'; inversion Hj.
      + destruct j as [|j']; [lia|]. simpl in Hi. destruct i'; inversion Hi.
    - destruct (Nat.leb a h) eqn:Ha_le_h.
      + (* a <= h: a :: h :: t *)
        pose proof (proj2 (Sorted_cons_iff h t) Hs) as [Ht Hfor_h].
        pose proof (proj1 (Nat.leb_le a h) Ha_le_h) as Hah.  (* a <= h *)
        assert (Forall (le a) (h :: t)) as Hforall_a.
        { constructor.
          - exact Hah.
          - eapply Forall_le_lift; [exact Hah | exact Hfor_h]. }
        (* Use proj1 : (Sorted (h::t) /\ Forall (le a) (h::t)) -> Sorted (a::h::t) *)
        exact ((proj1 (Sorted_cons_iff a (h :: t))) (conj Hs Hforall_a)).
      + (* a > h: h :: insert a t *)
        pose proof (proj2 (Sorted_cons_iff h t) Hs) as [Ht Hfor_h].
        specialize (IH Ht).
        pose proof (proj1 (Nat.leb_gt a h) Ha_le_h) as Hagt.  (* h < a *)
        assert (Forall (le h) (insert a t)) as Hforall_h.
        { apply Forall_le_preserved_by_insert; [exact Hfor_h|].
          apply Nat.lt_le_incl; exact Hagt. }
        (* Again need pair -> Sorted (h :: insert a t) *)
        exact ((proj1 (Sorted_cons_iff h (insert a t))) (conj IH Hforall_h)).
  Qed.


  (*---------------------------- Exercice 4.2 ----------------------------*)

  Lemma insertion_sort_sorted :
    forall (l : list nat),
      Sorted (insertion_sort l).
  Proof.
    induction l as [| h t IH ]; simpl.
    - (* Sorted [] *)
      unfold Sorted. intros i j iv jv Hij Hi Hj.
      destruct i as [|i']; simpl in Hi.
      + (* i = 0 *) discriminate.
      + (* i = S i' *)
        destruct j as [|j']; [lia|].
        simpl in Hi. discriminate.
    - (* Sorted (insert h (insertion_sort t)) *)
      apply insert_sorted. exact IH.
  Qed.

  End Exercice4.


  (*---------------------------- Exercice 5 ----------------------------*)

  Module Exercice5.
  Import Exercice1.
  Import Exercice2.
  Import Exercice3.
  Import Exercice4.

  Definition is_a_sorting_algorithm (f: list nat -> list nat): Prop :=
    forall (l: list nat),
      Permutation l (f l) /\ Sorted (f l).

  Lemma insertion_sort_is_a_sorting_algorithm :
    is_a_sorting_algorithm insertion_sort.
  Proof.
    unfold is_a_sorting_algorithm.
    intro l.
    split.
    - apply insertion_sort_perm.
    - apply insertion_sort_sorted.
  Qed.

  End Exercice5.

  (*---------------------------- Exercice 6 - Moderate ----------------------------*)

  Module Exercice6.

  Function bubble_pass (l: list nat) {measure length}: list nat :=
    match l with
      | [] => []
      | [x] => [x]
      | x :: y :: l' =>
        if x <? y then
          x :: bubble_pass (y :: l')
        else
          y :: bubble_pass (x :: l')
    end.
  Proof.
    all:
      intros;
      simpl;
      lia.
  Qed.

  Definition bubble_sort (l: list nat): list nat :=
    Nat.iter (length l) bubble_pass l.

  (*---------------------------- Exercice 6.1 ----------------------------*)


Lemma bubble_pass_perm :
  forall (l : list nat),
    Permutation l (bubble_pass l).
Proof.
  intro l.
  functional induction (bubble_pass l) using bubble_pass_ind.
  - (* [] *) apply Permutation_refl.
  - (* [x] *) apply Permutation_refl.
  - (* x :: y :: l', with x <? y = true *)
    apply perm_skip.
    remember (y :: l') as r eqn:Hr. exact IHl0.
  - (* x :: y :: l', with x <? y = false *)
    eapply perm_trans.
    + apply perm_swap.
    + apply perm_skip. exact IHl0.
Qed.


  End Exercice6.

